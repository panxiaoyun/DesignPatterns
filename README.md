# DesignPatterns

## 代理模式
---

结构型模式
类的适配器模式-**对象的适配器模式**-接口的适配器模式

### 代理模式的应用场景：
如果已有的方法在使用的时候需要对原有的方法进行改进，此时有两种办法：
1、修改原有的方法来适应。这样违反了“对扩展开放，对修改关闭”的原则。
2、就是采用一个代理类调用原有的方法，且对产生的结果进行控制。这种方法就是代理模式。???修改之后，调用方使用代理类来调用方法？

代理对象构造函数有看见两种写法
```
    private RealPursuit mRealPursuit;
    // 一：把真实对象作为一个参数传进来，
    public OtProxyPursuit(RealPursuit realPursuit){
        this.mRealPursuit = realPursuit;
    }
    
    // 二：在构造函数中直接new一个，
     public ProxyPursuit(SchoolGirl girl){
        if(mRealPursuit == null){
            mRealPursuit = new RealPursuit(girl);
        }
    }
```

可能有人会说，怎么感觉跟装饰器模式那么像呢？确实，在代码层次而言，两者确实比较接近。而主要的不同在于两个模式背后所蕴含的思想：
装饰器模式主要用来替代继承，为的是给一个现有的类增加新的功能，客户端关心的是装饰后的类所具有的功能；而代理模式为的是对被代理对象提供访问控制，客户端关心的实际上还是被代理对象所具有的功能。

### 优点
协调调用者和被调用者，降低了系统的耦合度
代理对象作为客户端和目标对象之间的中介，起到了保护目标对象的作用

### 缺点
由于在客户端和真实主题之间增加了代理对象，因此会造成请求的处理速度变慢；
实现代理模式需要额外的工作（有些代理模式的实现非常复杂），从而增加了系统实现的复杂度。
